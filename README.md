# 64-bit Low-Level Register-based Quantum Virtual Machine
###### 64-битная Низкоуровневая Регистровая Квантовая Виртуальная Машина

### О проекте
Квантовая виртуальная машина была написана по приколу. Но она работает! 
<br/>Я прекрасно понимаю, что у нее есть кучу недостатков и недоделанных мест, но если пытаться это все исправлять, то лучше будет начинать с нуля. Возможно, может быть, если повезет, когда-нибудь я это сделаю.
<br/>*P.S. Комментариев в коде нет :')*
<br/>
### Навигация
Если вы не знаете языков ассемблера, то начинайте чтение с пункта [**Свой язык ассемблера (QASM)**](#qasm).

 * [**Регистры**](#regs)
   * [Системные](#sregs)
   * [Классические *+опкоды*](#cregs)
   * [Квантовые](#qregs)
 * [**Память**](#mem)
   * [Программируемая](#mmem)
   * [Стек](#smem)
   * [Таблица меток](#ltmem)
   * [Таблица переменных](#dtmem)
 * [**Кубиты**](#qubits)
   * [Принцип работы](#qubitoppr)
   * [Реализованные операции](#qubits2)
 * [**Свой язык ассемблера (QASM)**](#qasm)
   * [Синтаксис](#qasm_syntax)
   * [Инструкции](#qasm_instrs)
     * [Стандартные *+опкоды*](#qasm_cinstrs)
     * [Квантовые *+опкоды*](#qasm_qinstrs)
   * [Метки](#qasm_lbls)
   * [Функции](#qasn_fns)
   * [Переменные](#qasm_datas)
     * [Косплей на массивы](#qasm_arrays)
 * [**Дебаг версия**](#dbg)
 * [**Сообщения об ошибках**](#errs)
   * [Ошибки неверных параметров запуска](#errs1)
   * [Ошибки синтаксиса](#errs2)
   * [Непредусмотренные виды ошибок](#errs3)
 * [**Флаги при запуске**](#flags)
 * [**Примеры простых программ**](#1prgs)
   * [1](#1prg1)
   * [2](#1prg2)
   * [3](#1prg3)
 * [**Можно и посложнее**](#2prgs)
   * [1](#2prgs1)
<br/>
<br/>

<a id="regs"></a>
## Регистры

<a id="sregs"></a>
#### Системные регистры
Я их выделил в отдельную категорию, т.к. с ними нельзя взаимодействовать в коде, они нужны исключительно для работы виртуальной машины.
 - `prgc` *(англ. program counter)* - удерживает адрес следующей команды, которая будет выполняться процессором. prgc указывает на текущую позицию в коде программы и увеличивается после каждой выполненной команды. Он обеспечивает последовательное выполнение команд, определяя порядок, в котором выполняются инструкции. Также, инструкции условных прыжков для своей работы просто меняют его значение.
 - `sp` *(англ. stack pointer)* - удерживает адрес текущей вершины стека, где хранятся локальные переменные и параметры функций.
 - `fp` *(англ. frame pointer)* - удерживает адрес начала текущего фрейма стека. Фрейм стека представляет собой область памяти, выделенную для отдельного вызова функции.
<br/>

<a id="cregs"></a>
#### Классические регистры
Классические регистры в моей виртуальной машине организованы в иерархическую структуру, где каждый регистр является подмножеством более крупного регистра. Эта структура позволяет использовать регистры разного размера в зависимости от требований выполняемой задачи.
<br/>Например, регистр **eax** является 32-битной частью 64-битного регистра **rax**. Это означает, что при выполнении 32-битной операции можно использовать регистр **eax**, а при выполнении 64-битной операции необходимо использовать регистр **rax**.
Или, например, регистры **ch** и **cl** являются первым и вторым байтом регистра **cx** соответственно.
<br/>Это можно представить вот так:
```bash
rax: 00 00 00 00 00 00 00 07
eax:             00 00 00 07
ax:                    00 07
ah:                    00
al:                       07
```
*При помощи 7 я хотел показать, что все эти регистры ссылаются на один и тот же участок памяти.*
<br/>Использование классических регистров аналогично использованию регистров в других ЭВМ. Они используются для хранения временных данных, результатов вычислений, адресов памяти и других значений. Иерархическая структура регистров позволяет оптимизировать использование памяти, выбирая регистр соответствующего размера для конкретной задачи.
###### Вот таблица всех классических регистров:
<table>
  <thead>
    <tr>
      <th>Опкод</th>
      <th>Название</th>
      <th>Размер, бит</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x5A</td>
      <td>rax</td>
      <td>64</td>
    </tr>
    <tr>
      <td>0x5B</td>
      <td>rbx</td>
      <td>64</td>
    </tr>
    <tr>
      <td>0x5C</td>
      <td>rcx</td>
      <td>64</td>
    </tr>
    <tr>
      <td>0x5D</td>
      <td>rdx</td>
      <td>64</td>
    </tr>
    <tr>
      <td>0x4A</td>
      <td>eax</td>
      <td>32</td>
    </tr>
    <tr>
      <td>0x4B</td>
      <td>ebx</td>
      <td>32</td>
    </tr>
    <tr>
      <td>0x4C</td>
      <td>ecx</td>
      <td>32</td>
    </tr>
    <tr>
      <td>0x4D</td>
      <td>edx</td>
      <td>32</td>
    </tr>
    <tr>
      <td>0x3A</td>
      <td>ax</td>
      <td>16</td>
    </tr>
    <tr>
      <td>0x3B</td>
      <td>bx</td>
      <td>16</td>
    </tr>
    <tr>
      <td>0x3C</td>
      <td>cx</td>
      <td>16</td>
    </tr>
    <tr>
      <td>0x3D</td>
      <td>dx</td>
      <td>16</td>
    </tr>
    <tr>
      <td>0x2A</td>
      <td>ah</td>
      <td>8</td>
    </tr>
    <tr>
      <td>0x2B</td>
      <td>bh</td>
      <td>8</td>
    </tr>
    <tr>
      <td>0x2C</td>
      <td>ch</td>
      <td>8</td>
    </tr>
    <tr>
      <td>0x2D</td>
      <td>dh</td>
      <td>8</td>
    </tr>
    <tr>
      <td>0x1A</td>
      <td>al</td>
      <td>8</td>
    </tr>
    <tr>
      <td>0x1B</td>
      <td>bl</td>
      <td>8</td>
    </tr>
    <tr>
      <td>0x1C</td>
      <td>cl</td>
      <td>8</td>
    </tr>
    <tr>
      <td>0x1D</td>
      <td>dl</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
<br/>

<a id="qregs"></a>
#### Квантовые регистры
В отличии от классических, квантовые регистры изначально не объявлены, они создаются по ходу выполнения программы при помощи [инструкции **qreg**](#qasm_qinstrs_qreg).
Такие регистры имеют свои собственные имена и хранят [кубиты](#qubits) в количестве от 1 до 255. Все это задается при создании квантового регистра. 
<br/>Рекомендую воспринимать квантовый регистр как массив кубитов, к которому можно обращаться по индексу для доступа к кубиту.
<br/>Также стоит сказать, что виртуальная машина конвертирует все имена квантовых регистров (а еще [переменных](#qasm_datas) и [меток](#qasm_lbls)) в двухбайтовые коды, а следовательно количество квантовых регистров не может быть больше 65536. (Кому вообще столько их пригодится?)
И нет, коды переменных, меток и квантовых регистров никак не связаны, например, одновременно могут существовать все эти три штуки с кодом 0x0001 и все будет исправно работать.
<br/>
<br/>

<a id="mem"></a>
## Память
*Не считая [регистры](#regs), о них я писал в другом пункте.*

<a id="mmem"></a>
#### Программируемая
Когда виртуальная машина запускается, она принимает на вход файл с кодом на [QASM](#qasm). Далее он конвертируется в байткод, который записывается в память виртуальной машины.
<br/>После этого запускается процессор, который пробегается как раз таки по этой самой памяти, считывая из нее байты. Например, вот такой код на QASM:
```asm
mov ax, 3
add ax, 4
hlt
```
<br/>(Этот код кладет в регистр **ax** 3, а потом прибавляет к хранимому в нем значению 4). 
<br/>Запустив этот код командой: `./qvm -i file.qasm -b 16`, виртуальная машина запишет в свою память вот такой байткод:
```bash
11 3a 00 03 21 3a 00 04 ff 00 00 00 00 00 00 00
```
`11` - опкод [инструкции **mov**](#qasm_cinstrs_mov)
<br/>`3a` - опкод [классического регистра](#cregs) **ax**
<br/>`00` и `03` - эти 2 байта обозначают литерал 3 *(2 байта, т.к. регистр **ax** 2-ух байтовый)*
<br/>`21` - опкод [инструкции **add**](#qasm_cinstrs_add)
<br/>`3a` - опкод [классического регистра](#cregs) **ax**
<br/>`00` и `04` - эти 2 байта обозначают литерал 4 *(2 байта, т.к. регистр **ax** 2-ух байтовый)*
<br/>`ff` - опкод [инструкции **hlt**](#qasm_cinstrs_hlt)

<br/>И еще 7 нулевых байтов - это не заполненная память. Всего же 16 байтов в памяти из-за команды запуска, где это указывалось. Подробнее о [флагах при запуске](#flags).
<br/><br/>Программируемая память в моей виртуальной машине делится на 2 типа: статическая и код. *Динамическую мне было влом делать.* В первой хранятся [переменные](#qasm_datas), а во второй, очевидно, сам код. Разделяются эти секции при помощи `section`:
```asm
entry _start

section .data   ; статическая секция
; объявление всяких переменных

section .text   ; секция кода
    _start:
    ; наш код со всякими инструкциями по типу mov, add и т.д.
```
Здесь использовались `entry` и [метка](#qasm_lbls) `_start`. При помощи них, [системный регистр **prgc**](#sregs), в самом начале программы сразу же устанавливается на местоположение метки `_start` в коде и программа начинает исполняться. Если код начнет исполняться с статической секции, или секция кода закончится и процессор дойдет до статической секции, то выдаст ошибку. И это не говоря уже о том, что процессор не умеет обрабатывать `section`, которые тоже имеют свой опкод - `aa` и еще один байт: либо `01`, либо `02` в зависимости от того, статическая секция, или секция кода соответсвенно. Так что рекомендую просто делать как в примере с меткой _start.
<br/>*P.S. Под капотом, **entry** - это просто [инструкция **jmp**](#qasm_cinstrs_jmp). Добавил я эту **entry**, только чтобы больше соответсвовать синтаксису [NASM](https://nasm.us/).*
<br/>

<a id="smem"></a>
#### Стек
В моей виртуальной машине, стек является вектором 8-ми байтовых значений. 
<br/>В него можно класть значения при помощи [инструкции **push**](#qasm_cinstrs_push) и забирать их оттуда при помощи [инструкции **pop**](#qasm_cinstrs_pop):
```asm
push eax   ; сохраняем на стек eax и ebx
push ebx

add eax, ebx   ; некоторые операции с этими регистрами
mov ecx, eax

pop ebx   ; возвращаем регистрам их изначальные значения
pop eax
```
Тут стоит заметить, что хоть регистры **eax** и **ebx** 4-х байтовые, но на стеке их значения все равно будут занимать по 8 байт.
<br/><br/>Также, стек нужен для работы инструкций **call** и **ret**, которые по сути являются аналогом функций из высокоуровневых языков программирования. Как раз для них же и нужен [системный регистр **fp**](#sregs), за счет него работают фреймы в моем стеке. 
<br/>*Я не вижу особого смысла в объснении работы фреймов, но если интересно, то найдите в проекте файл `Memory.hpp`, там будет класс `Memory`, где вы найдете методы `enter_frame` и `exit_frame`, реализации же которых лежат в файле `Memory.cpp`. Удачи.*
<br/>

<a id="ltmem"></a>
#### Таблица меток
Как я писал ранее, все [метки](#qasm_lbls) в коде на [QASM](#qasm), виртуальная машина конвертирует в 2-ух байтовые коды, по типу 0x0001, 0x0002 и т.д. Они еще перед запуском процессора записываются в вот такую таблицу: 
```c
std::unordered_map<u16, u32> labels_addresses;
```
Здесь значение с типом **u16** *(uint_16t)* - это **код метки**, который будет встречаться в байткоде QASM программы в jmp-подобных инструкциях при упоминании метки, которой присвоили этот код.
<br/>А под типом **u32** *(uint_32t)* хранится **адрес метки** в байткоде. Когда процессор встретит код метки, он возьмет ее адрес именно из этой таблицы. 
<br/>Приведу пример:
```asm
jmp _test

_test:
    mov al, 1
    hlt
```
Этот код конвертируется в вот такой байткод:
```bash
48 00 00 11 1a 01 ff 00 00 00 00 00 00 00 00 00
```
`48` - опкод [инструкции **jmp**](#qasm_cinstrs_jmp)
<br/>`00` и `00` - эти 2 байта являются **кодом метки** `_test` *(они оба нулевые, т.к. первый код - 0x0000, если в программе появится вторая метка, у нее будет код 0x0001 и т.д.)*
<br/>`11` - опкод [инструкции **mov**](#qasm_cinstrs_mov) *(на этот байт ссылается адрес метки `_test`)*
<br/>`1a` - опкод [классического регистра](#cregs) **al**
<br/>`01` - этот 1 байт обозначает литерал 1 *(1 байт, т.к. регистр **al** 1-но байтовый)*
<br/>`ff` - опкод [инструкции **hlt**](#qasm_cinstrs_hlt)

Думаю, теперь стало достаточно очевидно, как устроены метки в моей виртуальной машине.
<br/>

<a id="dtmem"></a>
#### Таблица переменных
Аналогично [меткам](#qasm_lbls), все имена [переменных](#qasm_datas) конвертируются в такие же 2-ух байтовые коды, которые точно так же записываются в похожую таблицу:
```c
std::unordered_map<u16, u32> data_addresses;
```
**u16** *(uint_16t)* - это **код переменной**.
<br/>**u32** *(uint_32t)* - это **адрес переменной** в байткоде.
<br/>Пример:
```asm
jmp _lbl

a byte 13

_lbl:
    mov al, &a
    hlt
```
Из этого QASM кода мы получаем вот такой байткод:
```bash
48 00 00 01 0d 12 1a 00 00 ff 00 00 00 00 00 00
```
`48` - опкод [инструкции **jmp**](#qasm_cinstrs_jmp)
<br/>`00` и `00` - эти 2 байта являются **кодом метки** `_lbl` *(они оба нулевые, т.к. первый код - 0x0000, если в программе появится вторая метка, у нее будет код 0x0001 и т.д.)*
<br/>`01` - этот байт говорит о том, что переменная `a` занимает 1 байт *(да, ничего лучше на тот момент я не придумал, кстати, адрес переменной ссылается именно на этот байт)*
<br/>`0d` - этот байт обозначает литерал 13
<br/>`12` - опкод [инструкции **mov**](#qasm_cinstrs_mov) (да, в прошлые разы он был `11`, объяснение этому находится в пункте [Инструкции](#qasm_instrs))
<br/>`1a` - опкод [классического регистра](#cregs) **al**
<br/>`00` и `00` - эти 2 байта являются **кодом переменной** `a` *(они оба нулевые, т.к. первый код - 0x0000, если в программе появится вторая переменная, у нее будет код 0x0001 и т.д.)*
<br/>`ff` - опкод [инструкции **hlt**](#qasm_cinstrs_hlt)

Опять же, в целом, все интуитивно понятно.
<br/>
<br/>

<a id="qubits"></a>
## Кубиты
Что такое кубит, можно прочитать и на [вики](https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D0%B1%D0%B8%D1%82).

<a id="qubitoppr"></a>
#### Принцип работы
В моей квантовой виртуальной машине кубит по сути является структурой с двумя полями, оба являются комплексными числами из std:  
```c
std::complex<double> alpha;
std::complex<double> beta;
```
А так же метод этой структуры - `measure`, который измеряет `alpha_probability`, при помощи [std::norm](https://en.cppreference.com/w/cpp/numeric/complex/norm):
```c
double alpha_probability = std::norm(alpha);
```
После, этот метод сравнивает это значение с рандомным числом и в зависимости от результа, мы получаем значение измеренного кубита: 0, или 1. 
<br/>Такая реализация кубита соответсвует формуле `Z = a|0⟩ + b|1⟩`, так что, мое решение можно назвать одним из верных. Я на это надеюсь. *~~(Хотя, спустя полгода, теперь я пишу эту доку и мне кажется, что где-то тут, что-то не так.)~~* 
<br/>Все операции с кубитами прописаны как методы квантовых регистров (за исключением [операции **RST**](#qop_rst)).
<br/>

<a id="qubitoppr"></a>
#### Реализованные операции
// TODO:
